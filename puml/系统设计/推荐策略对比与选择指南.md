# 推荐策略对比与选择指南

## 📊 策略对比矩阵

### 完整对比表

| 维度 | User-Based CF | Item-Based CF | Content-Based | Hybrid | Hot |
|------|---------------|---------------|---------------|--------|-----|
| **优先级** | 10 | 20 | 30 | 5 | 90 |
| **算法复杂度** | 高 O(N²) | 中 O(M²) | 低 O(M) | 高 | 低 O(1) |
| **响应时间** | 200-500ms | 100-200ms | 50-100ms | 300-600ms | <50ms |
| **准确度** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐ |
| **多样性** | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ |
| **新颖性** | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐ | ⭐ |
| **可解释性** | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **冷启动** | ❌ 差 | ❌ 差 | ✅ 好 | ⚠️ 中等 | ✅ 优秀 |
| **数据依赖** | 用户行为 | 药品关联 | 药品属性 | 多源数据 | 统计数据 |
| **适用用户** | 老用户 | 所有用户 | 新老用户 | 老用户 | 新用户 |
| **计算时机** | 实时/预计算 | 预计算 | 实时 | 实时 | 预计算 |
| **缓存友好** | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐⭐ |

---

## 🎯 策略选择决策树

```
开始
  │
  ├─ 用户ID是否存在？
  │   │
  │   ├─ 否 → 使用 HOT 策略 ✅
  │   │
  │   └─ 是 → 用户是否有行为历史？
  │       │
  │       ├─ 否（<5条）→ 使用 HOT 或 CONTENT_BASED ✅
  │       │
  │       └─ 是（≥5条）→ 场景类型？
  │           │
  │           ├─ 首页个性化 → 使用 HYBRID ⭐⭐⭐⭐⭐
  │           │
  │           ├─ 药品详情页 → 药品ID是否存在？
  │           │   ├─ 是 → 使用 ITEM_BASED_CF ⭐⭐⭐⭐
  │           │   └─ 否 → 使用 USER_BASED_CF ⭐⭐⭐
  │           │
  │           ├─ 购物车推荐 → 使用 USER_BASED_CF ⭐⭐⭐⭐
  │           │
  │           ├─ 中西药替代 → 使用 CONTENT_BASED ⭐⭐⭐⭐⭐
  │           │
  │           └─ 搜索结果页 → 使用 CONTENT_BASED ⭐⭐⭐⭐
```

---

## 📈 策略详细分析

### 1️⃣ User-Based CF（用户协同过滤）

#### 核心思想
"和你相似的用户喜欢的，你也可能喜欢"

#### 算法流程
```
1. 计算用户相似度矩阵
   用户A: [购买药品1, 药品3, 药品5]
   用户B: [购买药品1, 药品2, 药品5]
   相似度 = Jaccard(A, B) = 2/4 = 0.5

2. 找到Top-K相似用户
   用户123的相似用户: [用户456(0.85), 用户789(0.72), ...]

3. 推荐相似用户喜欢但目标用户未购买的药品
   推荐得分(药品X) = Σ(用户相似度 × 用户对药品X的偏好)

4. 排序返回Top-N
```

#### 优势场景
- ✅ 用户有丰富的行为历史（购买、浏览、收藏）
- ✅ 用户群体规模适中（1万-100万）
- ✅ 用户兴趣相对稳定
- ✅ 需要发现用户潜在兴趣

#### 局限性
- ❌ 新用户无推荐（冷启动）
- ❌ 计算量大，扩展性差
- ❌ 数据稀疏时效果差
- ❌ 流行偏差（热门药品更容易被推荐）

#### 优化建议
```java
// 1. 限制相似用户数量
int MAX_SIMILAR_USERS = 50;

// 2. 设置相似度阈值
double MIN_SIMILARITY = 0.3;

// 3. 使用缓存
@Cacheable(value = "user_similarity", key = "#userId")

// 4. 异步预计算
@Scheduled(cron = "0 0 2 * * ?")
public void precomputeUserSimilarity() { ... }
```

---

### 2️⃣ Item-Based CF（物品协同过滤）

#### 核心思想
"喜欢这个药品的人也喜欢那个药品"

#### 算法流程
```
1. 计算药品相似度矩阵
   药品A被用户: [1, 3, 5, 7]购买
   药品B被用户: [1, 2, 5, 8]购买
   相似度 = Cosine(A, B) = 0.67

2. 对于目标药品，查找相似药品
   药品123的相似药品: [药品456(0.92), 药品789(0.85), ...]

3. 可选：结合用户历史调整得分
   最终得分 = 相似度 × 用户对该类药品的偏好

4. 排序返回Top-N
```

#### 优势场景
- ✅ 药品详情页"相关推荐"
- ✅ 药品数量相对稳定
- ✅ 需要推荐相似/替代药品
- ✅ 对实时性要求高

#### 局限性
- ❌ 新药品无推荐
- ❌ 推荐同质化严重
- ❌ 难以发现跨品类推荐

#### 优化建议
```java
// 1. 预计算相似度矩阵（离线）
// 药品关系相对稳定，可以每天更新一次

// 2. 多维度相似度
- 成分相似度（余弦相似度）
- 功效相似度（标签匹配）
- 用户行为相似度（协同购买）

// 3. 分层索引
CREATE INDEX idx_medicine_sim_score 
ON medicine_similarity(medicine_id_1, similarity_score DESC);
```

---

### 3️⃣ Content-Based（基于内容）

#### 核心思想
"推荐与你喜欢的药品特征相似的其他药品"

#### 算法流程
```
1. 提取药品特征向量
   药品A: {
     类型: "感冒药",
     成分: ["对乙酰氨基酚", "马来酸氯苯那敏"],
     功效: ["解热", "镇痛", "抗过敏"],
     适应症: ["感冒", "发热", "头痛"]
   }

2. 计算特征相似度
   TF-IDF、Word2Vec、BERT等

3. 找到内容相似的药品
   相似度 = Cosine(向量A, 向量B)

4. 排序返回Top-N
```

#### 优势场景
- ✅ 中西药替代推荐
- ✅ 按功效/成分推荐
- ✅ 新药品推荐（无冷启动）
- ✅ 需要可解释性

#### 局限性
- ❌ 推荐同质化
- ❌ 难以发现用户新兴趣
- ❌ 依赖特征质量

#### 优化建议
```java
// 1. 多维特征融合
double score = 0.3 * 成分相似度 
             + 0.3 * 功效相似度
             + 0.2 * 类别相似度
             + 0.2 * 适应症相似度;

// 2. 引入语义理解
使用医药知识图谱、BERT模型

// 3. 结合用户偏好
过滤用户不感兴趣的药品类型
```

---

### 4️⃣ Hybrid（混合推荐）

#### 核心思想
"融合多个策略的优势，取长补短"

#### 融合方式

**方式1：加权融合**
```java
score(药品) = w1 × UserCF_score 
            + w2 × ItemCF_score
            + w3 × Content_score

// 权重可配置
weights:
  user-based: 0.4
  item-based: 0.4
  content-based: 0.2
```

**方式2：投票融合**
```java
// 出现次数越多，权重越高
finalScore = avgScore × log(出现次数 + 1)
```

**方式3：级联融合**
```
第一层：UserCF生成候选集（100个）
   ↓
第二层：ItemCF精排（50个）
   ↓
第三层：Content多样性补充（10个）
   ↓
最终结果：Top-20
```

#### 优势场景
- ✅ 首页个性化推荐
- ✅ 对推荐质量要求高
- ✅ 用户数据和药品数据都充足
- ✅ 可接受较长响应时间

#### 局限性
- ❌ 计算复杂度高
- ❌ 响应时间长（300-600ms）
- ❌ 需要多个策略都可用

#### 优化建议
```java
// 1. 并行执行子策略
CompletableFuture.allOf(cf1, cf2, cf3).join();

// 2. 设置超时
@Timeout(value = 500, unit = TimeUnit.MILLISECONDS)

// 3. 结果缓存
@Cacheable(value = "hybrid_rec", key = "#userId", ttl = 1800)

// 4. 智能权重
根据用户类型动态调整权重：
- 新用户：Content权重↑
- 老用户：UserCF权重↑
```

---

### 5️⃣ Hot（热门推荐）

#### 核心思想
"推荐最受欢迎的药品"

#### 算法流程
```
1. 统计药品热度指标
   热度 = w1 × 购买量 + w2 × 浏览量 + w3 × 收藏量

2. 可选：时间衰减
   最终热度 = 基础热度 × exp(-λ × 天数)

3. 分类排序
   按药品类型分组，每组Top-N

4. 定期更新（每天/每小时）
```

#### 优势场景
- ✅ 新用户冷启动
- ✅ 首页热门板块
- ✅ 兜底策略
- ✅ 营销活动推荐

#### 局限性
- ❌ 无个性化
- ❌ 马太效应
- ❌ 无新颖性

#### 优化建议
```java
// 1. 分类热门榜
按西药/中药/保健品分别统计

// 2. 时间窗口
近7天热度、近30天热度

// 3. 去重
避免推荐用户已购买的热门药品

// 4. 随机注入
10%概率推荐潜力药品（浏览增长快）
```

---

## 🔍 实战案例

### 案例1：电商首页推荐

**需求**：为所有用户提供个性化首页推荐

**策略组合**：
```java
if (用户已登录 && 行为数据 >= 10条) {
    使用 HYBRID 策略
    - UserCF: 40%
    - ItemCF: 40%
    - Content: 20%
} else if (用户已登录 && 行为数据 < 10条) {
    使用 HOT + CONTENT_BASED
    - 70%热门药品
    - 30%基于浏览历史的内容推荐
} else {
    使用 HOT 策略
    - 按药品类型展示热门榜单
}
```

**预期效果**：
- 点击率提升：15%+
- 转化率提升：8%+
- 用户停留时长：+30秒

---

### 案例2：药品详情页推荐

**需求**：推荐"相关药品"

**策略**：`ITEM_BASED_CF`

```java
RecommendationRequest request = RecommendationRequest.builder()
    .medicineId(currentMedicineId)
    .strategyName("ITEM_BASED_CF")
    .topN(6)
    .build();
```

**推荐理由模板**：
- "功效相似的药品"
- "同类药品推荐"
- "看了这个药品的人还看了..."

---

### 案例3：中西药互推

**需求**：中药详情页推荐对应的西药

**策略**：`CONTENT_BASED`

```java
RecommendationRequest request = RecommendationRequest.builder()
    .medicineId(traditionalMedicineId)
    .medicineType("WESTERN")  // 指定推荐西药
    .strategyName("CONTENT_BASED")
    .topN(5)
    .build();
```

**特征匹配**：
- 主治功效匹配
- 适应症匹配
- 禁忌症对比
- 副作用说明

---

## 📊 效果评估指标

### 在线指标

| 指标 | 说明 | 目标值 |
|------|------|--------|
| CTR（点击率） | 推荐点击数/推荐展示数 | > 5% |
| CVR（转化率） | 推荐购买数/推荐点击数 | > 2% |
| 人均点击数 | 平均每个用户点击推荐数 | > 1.5 |
| 覆盖率 | 被推荐的药品数/总药品数 | > 30% |
| 新颖性 | 推荐非热门药品占比 | > 20% |

### 离线指标

| 指标 | 说明 | 计算方式 |
|------|------|----------|
| 准确率 | 推荐正确的比例 | TP / (TP + FP) |
| 召回率 | 找到的相关药品比例 | TP / (TP + FN) |
| F1-Score | 准确率和召回率的调和平均 | 2PR / (P + R) |
| NDCG | 归一化折损累计增益 | - |
| 多样性 | 推荐结果的类别丰富度 | - |

---

## 🎨 最佳实践总结

### ✅ DO（推荐做法）

1. **优先使用混合策略**：HYBRID综合效果最好
2. **启用降级机制**：确保始终有推荐结果
3. **缓存热点数据**：相似度矩阵、热门榜单
4. **定期更新数据**：每天更新相似度和热度
5. **A/B测试验证**：对比不同策略效果
6. **监控关键指标**：CTR、CVR、响应时间

### ❌ DON'T（避免做法）

1. **不要单一策略**：容易出现推荐失败
2. **不要忽略冷启动**：新用户体验很重要
3. **不要过度个性化**：也要推荐热门和新品
4. **不要忽略性能**：响应时间>500ms用户流失
5. **不要静态推荐**：定期更新模型和数据
6. **不要无脑推荐**：考虑业务规则（库存、合规）

---

## 📚 进阶阅读

- 📖 完整架构文档：`推荐系统架构设计文档.md`
- 🚀 快速入门指南：`推荐系统快速入门.md`
- 💻 代码示例：`/src/main/java/com/ailian/product/recommendation/`

---

**最后更新**：2025-11-14  
**文档维护**：开发团队

